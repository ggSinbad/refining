---
title: "MCSimulation"
author: "Sinbad"
date: "01/06/2021"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r}

IsAbsorbing <- function(TransitionMatrix){   #this tells us if a state in the transition matrix is absorbing or not - ie if the chance of moving from state a to state a on the next step is 1.
  
  NumberOfStates <- nrow(TransitionMatrix)
  
  abs <- c()
  
  for (i in 1:NumberOfStates){
    
    if(TransitionMatrix[ i , i ] == 1){
      
    
      
      abs <- c(abs, i)
      
      
    }
    
    
  }
  
  return(abs)
}

#the purpose of this function is so that we don't keep simulating when we know the MC is in an absorbing state. this will cut down the computation time

```


```{r}


LengthFixer <- function(Vector, DesiredLength){ #
  
  currentlength <- length(Vector)
  
  difference <- DesiredLength - currentlength
  
  ending <- rep(Vector[currentlength] , difference)
  
  Vector <- c(Vector, ending)
  
  return(Vector)
}
  
  #terminating the simulation early for absorbing states will result in output vectors of different lengths. this fixes a vector to a given length so that we can put them all in a matrix for analysis
  



```


```{r}

MCSim <- function(TransitionMatrix, StartingState, length){
  
  
  StateHistory <- StartingState #initialised vector where we will store results
  
  NumberOfStates <- nrow(TransitionMatrix)
  
  AbStates <- IsAbsorbing(TransitionMatrix) #vector of absorbing states in transition matrix
  
  
  
  for (i in 1:length){ 
    
    if (any(is.element(AbStates, StateHistory))==TRUE){ #at any point in the simulation if an element of the output vector is an absorbing state the simulation ends early
      
      StateHistory <- LengthFixer(StateHistory, length +1)
      
      return(StateHistory)
    }
    
    Example <- sample(NumberOfStates , size = 1 , prob = TransitionMatrix[ StateHistory[i] , ])
    
    StateHistory <- c( StateHistory , Example )
    
  }
  
  return(StateHistory)
  
}
  

```






```{r}

MCSimRepeater <- function(TransitionMatrix, StartingState, length, repetitions){ #to make our results useful, we run MCSim many times and collate the results for analysis. this function does this.
  
  
  
  reps <- c()
  
  for (i in 1:repetitions){
    
    reps <- cbind(reps , MCSim(TransitionMatrix, StartingState, length))
    
    
  }
  
  
  return(reps)
  
}
```


```{r}

hittingProbabilityCalculator <- function(SimResults , State) { # given simulation results and a state, find the probability that the state is reached. (hitting probability)

  
  totalOccurence <- c()
  for (i in 1:ncol(SimResults)) {
    totalOccurence <- c(totalOccurence , is.element(State, SimResults[,i]))
    
    
  }
  return(sum(totalOccurence)/ncol(SimResults))
}

  
```




```{r}

hittingTimeCalculator <- function(SimResults, State){
  
  totalOccurence <- c()
  firstOccurence <- c()
  
  for (i in 1:ncol(SimResults)){
    
    totalOccurence <- c(totalOccurence , is.element(State , SimResults[,i]))
    firstOccurence <-c(firstOccurence , match(State , SimResults[,i]))
  }
  
  return(sum(firstOccurence ,  na.rm=TRUE) / sum(totalOccurence))
  
}



```









```{r}


totalnines <- c()
firstnine <- c()

for (i in 1:10000){
  
  
  
  totalnines <- c(totalnines, is.element(9, testerer2[,i]))
  firstnine <- c(firstnine, match(9 , testerer2[,i]))
  
}

averagenine <- sum(firstnine, na.rm=TRUE) / sum(totalnines)

print(averagenine)
```


```{r}

totaltens <- c()
firstten <- c()

for (i in 1:10000){
  
  
  
  totaltens <- c(totaltens, is.element(10, testerer2[,i]))
  firstten <- c(firstten, match(10 , testerer2[,i]))
  
}

averageten <- sum(firstten, na.rm=TRUE) / sum(totaltens)

print(averageten)


```

```{r}

totalelevens <- c()
firsteleven <- c()

for (i in 1:10000){
  
  
  
  totalelevens <- c(totalelevens, is.element(11, testerer2[,i]))
  firsteleven <- c(firsteleven, match(11 , testerer2[,i]))
  
}

averageeleven <- sum(firsteleven, na.rm=TRUE) / sum(totalelevens)

print(averageeleven)



```

```{r}
binom.test(sum(totalnines) , 10000, 0.3464704)
```

